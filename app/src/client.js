// Generated by CoffeeScript 1.6.2
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(["/app/src/scene.js", "/app/src/authenticator.js", "/app/src/connector.js", "/app/src/uploader.js", "/app/src/elements/box.js", "/app/src/elements/model.js", "/app/components/jquery/dist/jquery.js", "/app/components/stats.js/build/stats.min.js", "/app/components/dat-gui/build/dat.gui.js"], function(Scene, Authenticator, Connector, Uploader, Box, Model, _jquery, _stats, _dat) {
    var Client;

    Client = (function() {
      function Client() {
        this.tick = __bind(this.tick, this);
        this.pointerlockchange = __bind(this.pointerlockchange, this);
        this.pointerlockerror = __bind(this.pointerlockerror, this);
        var ASPECT, FAR, NEAR, VIEW_ANGLE, axes;

        this.scene = new Scene;
        this.authenticator = new Authenticator;
        this.connector = new Connector(this.scene);
        this.connector.connect(this.authenticator);
        this.uploader = new Uploader(this);
        this.width = $(window).width();
        this.height = $(window).height();
        this.stats = new Stats();
        this.stats.setMode(0);
        this.stats.domElement.style.position = 'absolute';
        this.stats.domElement.style.left = '0px';
        this.stats.domElement.style.top = '0px';
        document.body.appendChild(this.stats.domElement);
        VIEW_ANGLE = 45;
        ASPECT = this.width / this.height;
        NEAR = 0.1;
        FAR = 400;
        this.tscene = new THREE.Scene();
        this.tscene.fog = new THREE.Fog(0xffffff, 200, 400);
        this.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        this.tscene.add(this.camera);
        this.camera.position.set(0, 10, 0);
        this.renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        this.renderer.setSize(this.width, this.height);
        this.renderer.shadowMapEnabled = true;
        this.renderer.setClearColor(0xffffff, 1);
        this.projector = new THREE.Projector();
        this.time = Date.now();
        this.addLights();
        this.addFloor();
        this.addControls();
        this.addInstructions();
        axes = new THREE.AxisHelper(100);
        this.tscene.add(axes);
        document.body.appendChild(this.renderer.domElement);
        this.tick();
      }

      Client.prototype.hasPointerLock = function() {
        return document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
      };

      Client.prototype.pointerlockerror = function(event) {
        return alert("[FAIL] There was an error acquiring pointerLock. You will not be able to use metaverse.sh.");
      };

      Client.prototype.pointerlockchange = function(event) {
        if (this.hasPointerLock()) {
          this.controls.enabled = true;
          this.showBlocker();
          return this.hideInstructions();
        } else {
          this.controls.enabled = false;
          this.showInstructions();
          return this.hideBlocker();
        }
      };

      Client.prototype.addInstructions = function() {
        var _this = this;

        return $("#instructions").show().click(function() {
          var element;

          element = document.body;
          document.addEventListener('pointerlockchange', _this.pointerlockchange, false);
          document.addEventListener('mozpointerlockchange', _this.pointerlockchange, false);
          document.addEventListener('webkitpointerlockchange', _this.pointerlockchange, false);
          document.addEventListener('pointerlockerror', _this.pointerlockerror, false);
          document.addEventListener('mozpointerlockerror', _this.pointerlockerror, false);
          document.addEventListener('webkitpointerlockerror', _this.pointerlockerror, false);
          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
          return element.requestPointerLock();
        });
      };

      Client.prototype.showBlocker = function() {
        this.blockerElement || (this.blockerElement = $("<div />").addClass("blocker").appendTo('body'));
        return this.blockerElement.show();
      };

      Client.prototype.hideBlocker = function() {
        if (this.blockerElement) {
          return this.blockerElement.hide();
        }
      };

      Client.prototype.showInstructions = function() {
        return $("#instructions").show();
      };

      Client.prototype.hideInstructions = function() {
        return $("#instructions").hide();
      };

      Client.prototype.addFloor = function() {
        var floorGeometry, floorMaterial, floorTexture;

        floorTexture = new THREE.ImageUtils.loadTexture('/public/images/grid.png');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(100, 100);
        floorMaterial = new THREE.MeshBasicMaterial({
          map: floorTexture
        });
        floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
        this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
        this.floor.position.y = 0;
        this.floor.rotation.x = -Math.PI / 2;
        this.floor.receiveShadow = true;
        return this.tscene.add(this.floor);
      };

      Client.prototype.addControls = function() {
        this.controls = new THREE.PointerLockControls(this.camera);
        this.controls.enabled = false;
        return this.tscene.add(this.controls.getObject());
      };

      Client.prototype.addLights = function() {
        var ambientLight, dirLight;

        dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(-1, 0.75, 1);
        dirLight.position.multiplyScalar(200);
        dirLight.name = "dirlight";
        this.tscene.add(dirLight);
        dirLight.castShadow = true;
        dirLight.shadowMapWidth = dirLight.shadowMapHeight = 512;
        ambientLight = new THREE.AmbientLight(0x111111);
        return this.tscene.add(ambientLight);
      };

      Client.prototype.generateMesh = function(element) {
        var cubeGeometry, loader, material, mesh,
          _this = this;

        element.tmodel = {};
        loader = new THREE.JSONLoader;
        loader.crossOrigin = "";
        if (element instanceof Box) {
          material = new THREE.MeshLambertMaterial({
            color: 0xFF00aa
          });
          cubeGeometry = new THREE.CubeGeometry(1, 1, 1, 1, 1, 1);
          mesh = new THREE.Mesh(cubeGeometry, material);
          mesh.castShadow = true;
          this.tscene.add(mesh);
          element.tmodel = mesh;
        }
        if (element instanceof Model) {
          return loader.load(element.src, function(geometry, materials) {
            material = new THREE.MeshFaceMaterial(materials);
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            _this.tscene.add(mesh);
            return element.tmodel = mesh;
          });
        }
      };

      Client.prototype.detectCollision = function(x, y) {
        var i, intersects, raycaster, vector, _i, _len;

        vector = new THREE.Vector3((x / this.width) * 2 - 1, -(y / this.height) * 2 + 1, 0.5);
        console.log(this.camera);
        this.projector.unprojectVector(vector, this.camera);
        raycaster = new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());
        intersects = raycaster.intersectObjects([this.floor]);
        for (_i = 0, _len = intersects.length; _i < _len; _i++) {
          i = intersects[_i];
          return i.point;
        }
        return console.log('sadface');
      };

      Client.prototype.assetServerHost = function() {
        return window.location.host.split(':')[0] + ":8090";
      };

      Client.prototype.addHomer = function() {
        var loader,
          _this = this;

        loader = new THREE.JSONLoader;
        return loader.load('/public/models/homer.js', function(geometry, materials) {
          var material, mesh;

          material = new THREE.MeshFaceMaterial(materials);
          mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.y = -Math.PI / 2;
          mesh.castShadow = true;
          mesh.scale.x = mesh.scale.y = mesh.scale.z = 40.0;
          _this.tscene.add(mesh);
          return _this.selectModel(mesh);
        });
      };

      Client.prototype.addModel = function(url, position) {
        var loader,
          _this = this;

        loader = new THREE.JSONLoader;
        return loader.load(url, function(geometry) {
          var material, mesh;

          material = new THREE.MeshLambertMaterial({
            color: 0xDDDDDD
          });
          mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.y = -Math.PI / 2;
          mesh.castShadow = true;
          mesh.position = position;
          mesh.scale.x = mesh.scale.y = mesh.scale.z = 40.0;
          _this.tscene.add(mesh);
          return _this.selectModel(mesh);
        });
      };

      Client.prototype.selectModel = function(mesh) {
        var f1, f2, f3, gui, max, min, range;

        return;
        gui = new dat.GUI();
        f1 = gui.addFolder('Rotation');
        f1.add(mesh.rotation, 'x', -Math.PI, Math.PI);
        f1.add(mesh.rotation, 'y', -Math.PI, Math.PI);
        f1.add(mesh.rotation, 'z', -Math.PI, Math.PI);
        range = 250;
        f2 = gui.addFolder('Position');
        f2.add(mesh.position, 'x', mesh.position.x - range, mesh.position.x + range);
        f2.add(mesh.position, 'y', mesh.position.y - range, mesh.position.y + range);
        f2.add(mesh.position, 'z', mesh.position.z - range, mesh.position.z + range);
        min = 0.1;
        max = 100;
        f3 = gui.addFolder('Scale');
        f3.add(mesh.scale, 'x', min, max);
        f3.add(mesh.scale, 'y', min, max);
        return f3.add(mesh.scale, 'z', min, max);
      };

      Client.prototype.addSuzanne = function(position) {
        var loader,
          _this = this;

        loader = new THREE.ColladaLoader();
        loader.options.convertUpAxis = true;
        return loader.load('/public/models/suzanne.dae', function(collada) {
          var model, _i, _len, _ref, _results;

          _ref = collada.scene.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            model = _ref[_i];
            if (!(model instanceof THREE.Mesh)) {
              continue;
            }
            model.scale.x = model.scale.y = model.scale.z = 20.0;
            model.rotation.x = Math.PI / 2;
            model.position = position;
            model.castShadow = true;
            _results.push(_this.tscene.add(model));
          }
          return _results;
        });
      };

      Client.prototype.tick = function() {
        var element, key, _ref;

        this.stats.begin();
        TWEEN.update();
        _ref = this.scene.childNodes;
        for (key in _ref) {
          element = _ref[key];
          if (!element.tmodel) {
            this.generateMesh(element);
          }
          element.tmodel.position = element.position;
          element.tmodel.rotation = element.rotation;
          element.tmodel.scale = element.scale;
        }
        this.controls.update(Date.now() - this.time);
        this.renderer.render(this.tscene, this.camera);
        this.stats.end();
        this.time = Date.now();
        return requestAnimationFrame(this.tick);
      };

      return Client;

    })();
    return Client;
  });

}).call(this);
